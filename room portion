350, 200, 600

{
	"sqf":200,
	"roomDim": [4,8],
	"imagePath": null,
	"roomName": "Solar",
	"containerDim": [4,8],
	"roomType": "Sleeping",
	"doors": [[4,-1], [3,-2]],
	"placementPts": 2,
	"affectedBy": ["Outdoor"],
	"effectPts": 2,
	"completed": false,
	"boardPosition": [null, null]
}

{
	"sqf":350,
	"roomDim": [4,14],
	"imagePath": null,
	"roomName": "Upper Hall",
	"containerDim": [4,14],
	"roomType": "Corridor",
	"doors": [[0,2], [4,2], [7,1], [7,-1], [6,-2], [2,-2], [-2,-2], [-6,-2], [-7,-1], [-7,1], [-4,2]],
	"placementPts": 1,
	"affectedBy": ["Food"],
	"effectPts": 1,
	"completed": false,
	"boardPosition": [null, null]
}


{
	"sqf": 600,
	"roomDim": ['polygon', [2,0], [12,0], [14,-2], [14,-6], [12,-8,], [2,-8], [0,-6], [0,-4]], // defined by top left corner
	"imagePath": null,
	"roomName": "Throne room",
	"containerDim": [14,8],
	"roomType": "Living",
	"doors": [[4,4], [7,-1], [4,-4], [-7,1]],
	"placementPts": 1,
	"affectedBy": ["Sleep"],
	"effectPts": 4,
	"completed": false,
	"boardPosition": [null, null]
}

// castle = [{
                //         "affectedBy": [],
                //         "boardPosition": [0, 0],
                //         "completed": false,
                //         "containerDim": [60, 60],
                //         "doors": [
                //             [30, 0],
                //             [60, 30],
                //             [0, 30]
                //         ],
                //         "effectPts": 0,
                //         "fence": null,
                //         "final": true,
                //         "imagePath": "images/foyer.png",
                //         "placementPts": 0,
                //         "points": [
                //             [15, 0],
                //             [45, 0],
                //             [60, 15],
                //             [60, 45],
                //             [45, 60],
                //             [15, 60],
                //             [0, 45],
                //             [0, 15]
                //         ],
                //         "roomName": "YellowFoyer",
                //         "roomType": "Corridor",
                //         "rotation": 0,
                //         "sqf": 125,
                //     },
                //     // {
                //     //     "roomName": "Solar",
                //     //     "imagePath": "images/200-solar.png",
                //     //     "sqf": 200,
                //     //     "roomType": "Sleeping",
                //     //     "placementPts": 2,
                //     //     "affectedBy": ["Outdoor"],
                //     //     "effectPts": 2,
                //     //     "completed": false,
                //     //     "boardPosition": [0, 0],
                //     //     "containerDim": [80, 40],
                //     //     "points": [
                //     //         [0, 0],
                //     //         [80, 0],
                //     //         [80, 40],
                //     //         [0, 40]
                //     //     ],
                //     //     "doors": [
                //     //         [80, 30],
                //     //         [0, 40]
                //     //     ],
                //     //     "fence": null,
                //     //     "rotation": 0,
                //     //     "final": true
                //     // }
                //     // , 
                //     // {
                //     //     "roomName": "Flute-Room",
                //     //     "imagePath": "images/150-fake-room-money-money.png",
                //     //     "sqf": 150,
                //     //     "roomType": "Activity",
                //     //     "placementPts": 3,
                //     //     "affectedBy": ["Living", "Sleep"],
                //     //     "effectPts": -1,
                //     //     "completed": false,
                //     //     "boardPosition": [-60, 0],
                //     //     "containerDim": [60, 60],
                //     //     "points": [
                //     //         [30, 30]
                //     //     ],
                //     //     "radius": 30,
                //     //     "doors": [
                //     //         [30, 0],
                //     //         [0, 30],
                //     //         [60, 30]
                //     //     ],
                //     //     "fence": null,
                //     //     "rotation": 0,
                //     //     "final": true
                //     // }
                //     // ,
                //     {
                //         "roomName": "Hallway",
                //         "imagePath": "images/150-hallway.png",
                //         "sqf": 150,
                //         "roomType": "Corridor",
                //         "placementPts": 0,
                //         "affectedBy": [],
                //         "effectPts": 0,
                //         "completed": false,
                //         "boardPosition": [0, 0],
                //         "containerDim": [120, 20],
                //         "points": [
                //             [0, 0],
                //             [120, 0],
                //             [120, 20],
                //             [0, 20]
                //         ],
                //         "doors": [
                //             [0, 10],
                //             [120, 10],
                //             [10, 0],
                //             [30, 0],
                //             [50, 0],
                //             [70, 0],
                //             [90, 0],
                //             [110, 0],
                //             [10, 20],
                //             [30, 20],
                //             [50, 20],
                //             [70, 20],
                //             [90, 20],
                //             [110, 20]
                //         ],
                //         "fence": null,
                //         "rotation": 0,
                //         "final": false
                //     }
                // ];



                                // var currentCastle = svg.append("g")
                //     .attr("id", "currentCastle");

                // var roomTiles = currentCastle.selectAll("g")
                //     .data(castle)
                //     .enter()
                //     .append("g")
                //     .attr("transform", function(d) {
                //         var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                //         var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                //         return "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")";
                //     })
                //     .call(drag)
                //     .on("dblclick", rotate);

                // var roomImages = roomTiles.append("image")
                //     .attr("xlink:href", function(d) {
                //         return d.imagePath;
                //     })
                //     .attr("height", function(d) {
                //         return d.containerDim[1];
                //     })
                //     .attr("width", function(d) {
                //         return d.containerDim[0];
                //     });

                // var polyRooms = roomTiles.append("polygon")
                //     .filter(function(d) {
                //         return !d.radius;
                //     })
                //     .attr("points", function(d) {
                //         return d.points.map(function(v) {
                //             return v.join(",");
                //         }).join(" ");
                //     })
                //     .style("stroke", "black")
                //     .style("stroke-width", "0")
                //     .classed("polygon", true)
                //     .classed("shadow", true)
                //     .classed("normal", true);
                // // .classed("normal", "normal" === checkOverlaps(d))
                // // .classed("overlapping", "overlapping" === checkOverlaps(d));

                // var circleRooms = roomTiles.append("circle")
                //     .filter(function(d) {
                //         return d.radius;
                //     })
                //     .attr("cx", function(d) {
                //         return d.points[0][0];
                //     })
                //     .attr("cy", function(d) {
                //         return d.points[0][1];
                //     })
                //     .attr("r", function(d) {
                //         return d.radius;
                //     })
                //     .style("stroke", "black")
                //     .style("stroke-width", "0")
                //     .classed("circle", true)
                //     .classed("shadow", true)
                //     .classed("normal", true);
                // // .classed("normal", "normal" === checkOverlaps(d))
                // // .classed("overlapping", "overlapping" === checkOverlaps(d));

                // d3.select(this).select(".shadow")
                //     .classed("normal", function(d) {
                //         return "normal" === checkOverlaps(d);
                //     })
                //     .classed("overlapping", function(d) {
                //         return "overlapping" === checkOverlaps(d);
                //     });


///*%*#$%@(#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)$%@#$)%@#*$%(@#$)%_@#$%)@#$(%*@#$%(@#$)%_@#$%)@#$%(@#$%*@#($%)@#$_%@#$)%(@#$%)
///#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)*%*#$%@(#$%(@#$%@#)$%)
///*%*#$%@(#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)$%@#$)%@#*$%(@#$)%_@#$%)@#$(%*@#$%(@#$)%_@#$%)@#$%(@#$%*@#($%)@#$_%@#$)%(@#$%)
///#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)*%*#$%@(#$%(@#$%@#)$%)
///*%*#$%@(#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)$%@#$)%@#*$%(@#$)%_@#$%)@#$(%*@#$%(@#$)%_@#$%)@#$%(@#$%*@#($%)@#$_%@#$)%(@#$%)
///#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)*%*#$%@(#$%(@#$%@#)$%)
///*%*#$%@(#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)$%@#$)%@#*$%(@#$)%_@#$%)@#$(%*@#$%(@#$)%_@#$%)@#$%(@#$%*@#($%)@#$_%@#$)%(@#$%)
///#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)#$%(@#$%@#)$%)@#$%)@#$*%@#$%(@#)*%*#$%@(#$%(@#$%@#)$%)


app.controller('GameBoardCtrl', function($scope) {});

app.directive('gameBoard', function($firebaseObject, gameFactory, gameStateFactory) {
    return {
        restrict: "EA",
        template: "<div id='gameBoard'></div>",
        link: function(scope, el, attr) {
            var width = el[0].clientWidth;
            var height = el[0].clientHeight;
            var agame;

            var userID = gameFactory.auth().$getAuth().uid;

            var userGame = $firebaseObject(gameFactory.ref().child('users').child(userID).child('game'));

            userGame.$loaded().then(function(data) {
                return data.$value;
            }).then(function(game) {
                console.log("game", game);
                agame = game;
                return $firebaseObject(gameFactory.ref().child('games').child(game));
            }).then(function(syncObject) {
                return syncObject.$bindTo(scope, 'game');
            }).then(function() {

                var currentUserIndex = gameStateFactory.getUserIndex(scope.game);
                var castle = scope.game.players[currentUserIndex].castle;

                var castleRef = gameFactory.ref().child('games').child(agame).child('players').child(currentUserIndex).child('castle');

                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------

                var drag = d3.behavior.drag()
                    .origin(function(d) {
                        return d;
                    })
                    .on("dragstart", dragstarted)
                    .on("drag", dragged)
                    .on("dragend", dragended);

                var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 5])
                    .on("zoom", zooming);

                // creating the underlying grid

                var svg = d3.select("#gameBoard")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    // .attr("viewbox", "0 0 2500 2500")
                    .call(zoom)
                    .on("dblclick.zoom", null);

                var gameGrid = svg.append("g");

                gameGrid.append("g")
                    .selectAll("line")
                    .data(d3.range(0, 2500))
                    .enter()
                    .append("line")
                    .attr("x1", function(d) {
                        return d * 10;
                    })
                    .attr("x2", function(d) {
                        return d * 10;
                    })
                    .attr("y1", -10)
                    .attr("y2", height + 10)
                    .style("stroke", "white")
                    .style("stroke-width", "0.5");

                gameGrid.append("g")
                    .selectAll("line")
                    .data(d3.range(0, 2500))
                    .enter()
                    .append("line")
                    .attr("x1", -10)
                    .attr("x2", width + 10)
                    .attr("y1", function(d) {
                        return d * 10;
                    })
                    .attr("y2", function(d) {
                        return d * 10;
                    })
                    .style("stroke", "white")
                    .style("stroke-width", "0.5");

                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------

                // adding tiles to the board

                var currentCastle = svg.append("g")
                    .attr("id", "currentCastle");

                function redrawCastle(castle) {
                    console.log("redrawing castle");
                    d3.select("#currentCastle").remove();

                    currentCastle = svg.append("g")
                        .attr("id", "currentCastle");

                    var roomTiles = currentCastle.selectAll("g")
                        .data(castle)
                        .enter()
                        .append("g")
                        .attr("transform", function(d) {
                            var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                            var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                            return "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")";
                        })
                        .call(drag)
                        .on("dblclick", rotate);

                    var roomImages = roomTiles.append("image")
                        .attr("xlink:href", function(d) {
                            return d.imagePath;
                        })
                        .attr("height", function(d) {
                            return d.containerDim[1];
                        })
                        .attr("width", function(d) {
                            return d.containerDim[0];
                        });


                    var polyRooms = roomTiles.append("polygon")
                        .filter(function(d) {
                            return !d.radius;
                        })
                        .attr("points", function(d) {
                            return d.points.map(function(v) {
                                return v.join(",");
                            }).join(" ");
                        })
                        .style("stroke", "black")
                        .style("stroke-width", "0")
                        .classed("polygon", true)
                        .classed("shadow", true)
                        .classed("normal", true);
                    // .classed("normal", "normal" === checkOverlaps(d))
                    // .classed("overlapping", "overlapping" === checkOverlaps(d));

                    var circleRooms = roomTiles.append("circle")
                        .filter(function(d) {
                            return d.radius;
                        })
                        .attr("cx", function(d) {
                            return d.points[0][0];
                        })
                        .attr("cy", function(d) {
                            return d.points[0][1];
                        })
                        .attr("r", function(d) {
                            return d.radius;
                        })
                        .style("stroke", "black")
                        .style("stroke-width", "0")
                        .classed("circle", true)
                        .classed("shadow", true)
                        .classed("normal", true);
                    // .classed("normal", "normal" === checkOverlaps(d))
                    // .classed("overlapping", "overlapping" === checkOverlaps(d));


                    //     d3.select(this).select(".shadow")
                    //         .classed("normal", function(d) {
                    //             return "normal" === checkOverlaps(d);
                    //         })
                    //         .classed("overlapping", function(d) {
                    //             return "overlapping" === checkOverlaps(d);
                    //         });
                }

                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------

                // functions

                function rotate(d, x) {
                    var temp;
                    d3.event.stopPropagation();
                    if (d.final !== true) {
                        d3.select(this)
                            .transition()
                            // .ease("elastic")
                            .duration(500)
                            .attr("transform", function(d) {
                                d.rotation = d.rotation + 90;
                                var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                                var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                                return "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")";
                            }).each("end", function() { castleRef.child(x).update({ "rotation": d.rotation, "points": d.points, "doors": d.doors }); });
                        // for (var i = 0; i < d.points.length; i++) {
                        //     temp = d.points[i][0] - (d.containerDim[0] / 2) + (d.containerDim[1] / 2);
                        //     d.points[i][0] = -d.points[i][1] + (d.containerDim[0] / 2) + (d.containerDim[1] / 2);
                        //     d.points[i][1] = temp;
                        // }

                        for (var j = 0; j < d.doors.length; j++) {
                            temp = -d.doors[j][0];
                            d.doors[j][0] = d.doors[j][1];
                            d.doors[j][1] = temp;
                        }

                    }
                }

                function dragstarted(d) {
                    if (d.final !== true) {
                        d3.event.sourceEvent.stopPropagation();
                        d3.select(this).classed("dragging", true);
                    }
                }

                function dragged(d, x) {
                    // var overlapStatus = checkOverlaps(d);
                    if (d.final !== true) {
                        d.boardPosition[0] += d3.event.dx;
                        d.boardPosition[1] += d3.event.dy;
                        var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                        var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                        d3.select(this)
                            .attr("transform", "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")");
                        // for (var i = 0; i < d.points.length; i++) {
                        //     d.points[i][0] += d3.event.dx;
                        //     d.points[i][1] += d3.event.dy;
                        // }
                        // for (var j = 0; j < d.doors.length; j++) {
                        //     d.doors[j][0] += d3.event.dx;
                        //     d.doors[j][1] += d3.event.dy;
                        // }

                        // d3.select(this).select(".shadow")
                        //     .classed("normal", "normal" === overlapStatus)
                        //     .classed("overlapping", "overlapping" === overlapStatus);
                    }
                }

                function dragended(d, x) {
                    if (d.final !== true) {
                        d3.select(this).classed("dragging", false);
                        d.boardPosition[0] = Math.round(d.boardPosition[0] / 10) * 10;
                        d.boardPosition[1] = Math.round(d.boardPosition[1] / 10) * 10;

                        for (var i = 0; i < d.points.length; i++) {
                            d.points[i][0] = Math.round(d.points[i][0] / 10) * 10;
                            d.points[i][1] = Math.round(d.points[i][1] / 10) * 10;
                        }
                        for (var j = 0; j < d.doors.length; j++) {
                            d.doors[j][0] = Math.round(d.doors[j][0] / 10) * 10 + d.boardPosition[0];
                            d.doors[j][1] = Math.round(d.doors[j][1] / 10) * 10 + d.boardPosition[1];
                        }
                        castleRef.child(x).update({ "rotation": d.rotation, "points": d.points, "doors": d.doors });
                    }
                }

                function checkOverlaps(d) {
                    for (var i = 0; i < castle.length; i++) {
                        if (castle[i].roomName === d.roomName) continue;
                        for (var j = 0; j < d.points.length; j++) {
                            if (d3_polygon.polygonContains(castle[i].points, [Math.round(d.points[j][0] / 10) * 10, Math.round(d.points[j][1] / 10) * 10])) {
                                return "overlapping";
                            }
                        }
                        for (var k = 0; k < castle[i].points.length; k++) {
                            if (d3_polygon.polygonContains(d.points.map(roundStuff), [castle[i].points[k][0], castle[i].points[k][1]])) {
                                return "overlapping";
                            }
                        }
                    }
                    return "normal";
                }

                function roundStuff(cv, ci, oa) {
                    return [Math.round(cv[0] / 10) * 10, Math.round(cv[1] / 10) * 10];
                }

                function zooming() {
                    gameGrid.attr("transform", "translate(" + d3.event.translate[0] % (10 * d3.event.scale) + "," + d3.event.translate[1] % (10 * d3.event.scale) + ")scale(" + d3.event.scale + ")");
                    currentCastle.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                }

                function checkLineIntersect(a, b, c, d) {
                    var r = pointDif(b, a);
                    var s = pointDif(d, c);
                    var numer = pointProd(pointDif(c, a), r);
                    var denom = pointProd(r, s);

                    if (numer === 0 && denom === 0) {
                        if (pointEq(a, c) || pointEq(a, d) || pointEq(b, c) || pointEq(b, d)) return true;
                        else return ((c[0] - a[0] < 0) != (c[0] - b[0] < 0) != (d[0] - a[0] < 0) != (d[0] - b[0] < 0)) || ((c[1] - a[1] < 0) != (c[1] - b[1] < 0) != (d[1] - a[1] < 0) != (d[1] - b[1] < 0));
                    }

                    if (!denom) return false;
                    var u = numer / denom;
                    var t = pointProd(pointDif(c, a), s) / denom;
                    return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);


                    function pointProd(a, b) {
                        return (a[0] * b[1]) - (a[1] * b[0]);
                    }

                    function pointDif(a, b) {
                        return [a[0] - b[0], a[1] - b[1]];
                    }

                    function pointEq(a, b) {
                        return (a[0] == b[0]) && (a[1] == b[1]);
                    }
                }

                castleRef.on('value', function(castle) {
                    var theCastle = castle.val();
                    console.log("Firebase saw a change in values, resyncing...");
                    console.log(theCastle);

                    redrawCastle(theCastle);
                });
                // redrawCastle(castle);
            });
        }
    };
});




// @#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%
// @#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%
// @#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%
// @#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%
// @#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%
// @#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%@#$%


app.controller('GameBoardCtrl', function($scope) {});

app.directive('gameBoard', function($firebaseObject, gameFactory, gameStateFactory) {
    return {
        restrict: "EA",
        scope: {
            gameId: "="
        },
        template: "<div id='gameBoard'></div>",
        link: function(scope, el, attr) {
            var width = el[0].clientWidth;
            var height = el[0].clientHeight;
            var agame;
            var castleLength = null;
            var userID = gameFactory.auth().$getAuth().uid;

            var userGame = $firebaseObject(gameFactory.ref().child('games').child(scope.gameId));

// <<<<<<< HEAD
            // userGame.$loaded()
            // .then(function(data) {
            //     return data.$value;
            // }).then(function(game) {
            //     agame = game;
            //     return $firebaseObject(gameFactory.ref().child('games').child(game));
            // }).then(function(syncObject) {
// =======
            userGame.$loaded()
            .then(function(syncObject) {
                agame = syncObject.$id;
// >>>>>>> master
                return syncObject.$bindTo(scope, 'game');
            }).then(function() {

                var currentUserIndex = gameStateFactory.getUserIndex(scope.game);
                // var castle = scope.game.players[currentUserIndex].castle;

                var castleRef = gameFactory.ref().child('games').child(scope.gameId).child('players').child(currentUserIndex).child('castle');

                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------
                // -------------------------------------------------------------------------------------------

                var drag = d3.behavior.drag()
                    .origin(function(d) {
                        return d;
                    })
                    .on("dragstart", dragstarted)
                    .on("drag", dragged)
                    .on("dragend", dragended);

                var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 5])
                    .on("zoom", zooming);

                // creating the underlying grid

                var svg = d3.select("#gameBoard")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .call(zoom)
                    .on("dblclick.zoom", null);

                var gameGrid = svg.append("g");

                gameGrid.append("g")
                    .selectAll("line")
                    .data(d3.range(0, 2500))
                    .enter()
                    .append("line")
                    .attr("x1", function(d) {
                        return d * 10;
                    })
                    .attr("x2", function(d) {
                        return d * 10;
                    })
                    .attr("y1", -10)
                    .attr("y2", height + 10)
                    .style("stroke", "white")
                    .style("stroke-width", "0.5");

                gameGrid.append("g")
                    .selectAll("line")
                    .data(d3.range(0, 2500))
                    .enter()
                    .append("line")
                    .attr("x1", -10)
                    .attr("x2", width + 10)
                    .attr("y1", function(d) {
                        return d * 10;
                    })
                    .attr("y2", function(d) {
                        return d * 10;
                    })
                    .style("stroke", "white")
                    .style("stroke-width", "0.5");

                var currentCastle = svg.append("g")
                    .attr("id", "currentCastle");

                // functions

                function rotate(d, x) {
                    var temp;
                    d3.event.stopPropagation();
                    if (d.final !== true) {
                        d3.select(this)
                            .transition()
                            // .ease("elastic")
                            .duration(500)
                            .attr("transform", function(d) {
                                d.rotation = d.rotation + 90;
                                var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                                var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                                return "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")";
                            }).each("end", function() { castleRef.child(x).update({ "rotation": d.rotation, "points": d.points, "doors": d.doors }); });
                        // for (var i = 0; i < d.points.length; i++) {
                        //     temp = d.points[i][0] - (d.containerDim[0] / 2) + (d.containerDim[1] / 2);
                        //     d.points[i][0] = -d.points[i][1] + (d.containerDim[0] / 2) + (d.containerDim[1] / 2);
                        //     d.points[i][1] = temp;
                        // }

                        for (var j = 0; j < d.doors.length; j++) {
                            temp = -d.doors[j][0];
                            d.doors[j][0] = d.doors[j][1];
                            d.doors[j][1] = temp;
                        }

                    }
                }

                function dragstarted(d) {
                    if (d.final !== true) {
                        d3.event.sourceEvent.stopPropagation();
                        d3.select(this).classed("dragging", true);
                    }
                }

                function dragged(d, x) {
                    if (d.final !== true) {
                        d.boardPosition[0] += d3.event.dx;
                        d.boardPosition[1] += d3.event.dy;
                        var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                        var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                        d3.select(this)
                            .attr("transform", "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")");
                        // for (var i = 0; i < d.points.length; i++) {
                        //     d.points[i][0] += d3.event.dx;
                        //     d.points[i][1] += d3.event.dy;
                        // }
                        // for (var j = 0; j < d.doors.length; j++) {
                        //     d.doors[j][0] += d3.event.dx;
                        //     d.doors[j][1] += d3.event.dy;
                        // }

                        // d3.select(this).select(".shadow")
                        //     .classed("normal", "normal" === overlapStatus)
                        //     .classed("overlapping", "overlapping" === overlapStatus);
                    }
                }

                function dragended(d, x) {
                    console.log(d);
                    if (d.final !== true) {
                        d3.select(this).classed("dragging", false);
                        d.boardPosition[0] = Math.round(d.boardPosition[0] / 10) * 10;
                        d.boardPosition[1] = Math.round(d.boardPosition[1] / 10) * 10;

                        for (var i = 0; i < d.points.length; i++) {
                            d.points[i][0] = Math.round(d.points[i][0] / 10) * 10;
                            d.points[i][1] = Math.round(d.points[i][1] / 10) * 10;
                        }
                        for (var j = 0; j < d.doors.length; j++) {
                            d.doors[j][0] = Math.round(d.doors[j][0] / 10) * 10;
                            d.doors[j][1] = Math.round(d.doors[j][1] / 10) * 10;
                        }
                        castleRef.child(x).update({ "boardPosition": d.boardPosition });
                    }
                }

                function checkOverlaps(d) {
                    for (var i = 0; i < castle.length; i++) {
                        if (castle[i].roomName === d.roomName) continue;
                        for (var j = 0; j < d.points.length; j++) {
                            if (d3_polygon.polygonContains(castle[i].points, [Math.round(d.points[j][0] / 10) * 10, Math.round(d.points[j][1] / 10) * 10])) {
                                return "overlapping";
                            }
                        }
                        for (var k = 0; k < castle[i].points.length; k++) {
                            if (d3_polygon.polygonContains(d.points.map(roundStuff), [castle[i].points[k][0], castle[i].points[k][1]])) {
                                return "overlapping";
                            }
                        }
                    }
                    return "normal";
                }

                function roundStuff(cv, ci, oa) {
                    return [Math.round(cv[0] / 10) * 10, Math.round(cv[1] / 10) * 10];
                }

                function zooming() {
                    gameGrid.attr("transform", "translate(" + d3.event.translate[0] % (10 * d3.event.scale) + "," + d3.event.translate[1] % (10 * d3.event.scale) + ")scale(" + d3.event.scale + ")");
                    currentCastle.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                }

                function checkLineIntersect(a, b, c, d) {
                    var r = pointDif(b, a);
                    var s = pointDif(d, c);
                    var numer = pointProd(pointDif(c, a), r);
                    var denom = pointProd(r, s);

                    if (numer === 0 && denom === 0) {
                        if (pointEq(a, c) || pointEq(a, d) || pointEq(b, c) || pointEq(b, d)) return true;
                        else return ((c[0] - a[0] < 0) != (c[0] - b[0] < 0) != (d[0] - a[0] < 0) != (d[0] - b[0] < 0)) || ((c[1] - a[1] < 0) != (c[1] - b[1] < 0) != (d[1] - a[1] < 0) != (d[1] - b[1] < 0));
                    }

                    if (!denom) return false;
                    var u = numer / denom;
                    var t = pointProd(pointDif(c, a), s) / denom;
                    return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);


                    function pointProd(a, b) {
                        return (a[0] * b[1]) - (a[1] * b[0]);
                    }

                    function pointDif(a, b) {
                        return [a[0] - b[0], a[1] - b[1]];
                    }

                    function pointEq(a, b) {
                        return (a[0] == b[0]) && (a[1] == b[1]);
                    }
                }

                castleRef.on('child_added', function(c) {
                    var newRoom = c.val();

                    var roomTile = currentCastle.append("g")
                        .datum(newRoom)
                        .attr("transform", function(d) {
                            var snapX = Math.round(d.boardPosition[0] / 10) * 10;
                            var snapY = Math.round(d.boardPosition[1] / 10) * 10;
                            return "rotate(" + d.rotation + " " + (snapX + d.containerDim[0] / 2) + " " + (snapY + d.containerDim[1] / 2) + "),translate(" + snapX + "," + snapY + ")";
                        })
                        .attr("id", function(d) {
                            var newSelector = "" + d.roomName.replace(/\W/g, '').toLowerCase();
                            return newSelector;
                        })
                        .call(drag)
                        .on("dblclick", rotate);

                    var roomImage = roomTile.append("image")
                        .attr("xlink:href", function(d) {
                            return d.imagePath;
                        })
                        .attr("height", function(d) {
                            return d.containerDim[1];
                        })
                        .attr("width", function(d) {
                            return d.containerDim[0];
                        });

                    var polyRoom = roomTile.append("polygon")
                        .filter(function(d) {
                            return !d.radius;
                        })
                        .attr("points", function(d) {
                            return d.points.map(function(v) {
                                return v.join(",");
                            }).join(" ");
                        })
                        .style("stroke", "black")
                        .style("stroke-width", "0")
                        .classed("polygon", true)
                        .classed("shadow", true)
                        .classed("normal", true);

                    var circleRoom = roomTile.append("circle")
                        .filter(function(d) {
                            return d.radius;
                        })
                        .attr("cx", function(d) {
                            return d.points[0][0];
                        })
                        .attr("cy", function(d) {
                            return d.points[0][1];
                        })
                        .attr("r", function(d) {
                            return d.radius;
                        })
                        .style("stroke", "black")
                        .style("stroke-width", "0")
                        .classed("circle", true)
                        .classed("shadow", true)
                        .classed("normal", true);
                });

                castleRef.on('child_removed', function(c) {
                    var removedRoom = c.val();
                    var removeSelector = "" + removedRoom.roomName.replace(/\W/g, '').toLowerCase();
                    d3.select("#" + removeSelector).remove();
                });
            });
        }
    };
});

